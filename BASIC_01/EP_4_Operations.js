// *********************** Operations ***********************

let value = 3
let negValue = -value
// console.log(negValue);

// console.log(2+2);
// console.log(2-2);
// console.log(2*2);
// console.log(2**3);
// console.log(2/3);
// console.log(2%3);

let str1 = "hello"
let str2 = " hitesh"

let str3 = str1 + str2
// console.log(str3);

// console.log("1" + 2);
// console.log(1 + "2");
// console.log("1" + 2 + 2);
// console.log(1 + 2 + "2");

// console.log( (3 + 4) * 5 % 3);

// console.log(+true);
// console.log(+"");

// let num1, num2, num3

// num1 = num2 = num3 = 2 + 2

// let gameCounter = 100
// ++gameCounter;
// // console.log(gameCounter);

// // link to study
// // https://tc39.es/ecma262/multipage/abstract-operations.html#sec-type-conversion

// // consversion with substarction
// let n1 = 10
// let n2 = "5"

// console.log("substarction");
// console.log(n1-n2); //5
// console.log(n2-n1); //-5

// console.log("Addition");
// console.log(n1+n2); //105
// console.log(n2+n1); //510

// console.log("Addition with 3 value");
// console.log("2"+1+1); //211
// console.log(2+1+"1"); //31

// console.log("substraction with 3 value");
// console.log("2"-1-1); //0
// console.log(2-1-"1"); //0

// console.log("Multiplication conversion");
// console.log("5"*2); //10
// console.log(5*"2"); //10

// console.log("5"*2*"10"); //100
// console.log(5*"2"*10); //100

// console.log("Division conversion");
// console.log("5"/2); //2.5
// console.log(5/"2"); //2.5

// console.log("5"/2/"5"); //0.5
// console.log(5/2/"5"); //0.5

// -------- comaprison operator------------
// console.log(2>"1");// it actually works return as true
// console.log(2>"2");// it actually works return as false

// console.log(2=="2"); //true
// console.log(2==="2"); //false

// console.log(null>0); //false
// console.log(null<0); //false
// console.log(null>=0); // true ** The reason console.log(null >= 0) returns true is because of how JavaScript handles comparisons involving null. When null is compared to a number using operators like >= or <=, it is treated as if it were 0. This is known as type coercion, where JavaScript tries to convert the values to a compatible type for the comparison.

// console.log(undefined>0); //false
// console.log(undefined<0); //false
// console.log(undefined>=0); //false
// // ** Since undefined is not 0, undefined is the absence of value, since the memory/spac is been allocated in the memory itself



