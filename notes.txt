
--let,var,const

const is very staraight forward meaning thats once the value is been declared then it cant be changed further on.

var is a bit tricky it can be changed anytime, the state changes and it reflects to all the all the variable with same name. 
This was the major issue using var.

let is similar to var but it has one difference it cant be changed once it is declared.
** let resolves this issue via scoping

--------------------------------------------------------------------------------------------------------------------------------

-- DataType and Ecma
// number => 2 to power 53  type is number
// bigint type is bugint
// string => "" type is string
// boolean => true/false type is boolean
// null => standalone value type is object
// undefined => tye is undefined
// symbol => unique type is symbol

undefined
Type: undefined is its own primitive type.
Meaning: It indicates that a variable has been declared but has not yet been assigned a value. It is also the default return value of functions that don't explicitly return something.
When to Use: Typically, you don't explicitly assign undefined to a variable. It's mainly used by JavaScript internally or to check if a variable has been initialized.

null
Type: null is an object (this is a quirk in JavaScript).
Meaning: It represents the intentional absence of any object value. It's often used to indicate that a variable should have no value.
When to Use: You can assign null to a variable when you want to explicitly indicate that it should be empty or have no value.
example: clearing the object value
         let obj={
            name:"John",
            age:21
         }
         obj=null;  // here we can observe that the object is ben cleared

         another example is:
         take tempearure as an example, if by chance the temperature is reset then 0 cant be the reset value since 0 is considered as a temperature value so here instead we use NULL
 
 ***  "use strict"; // treat all JS code as newer version       

--------------------------------------------------------------------------------------------------------------------------------
--DataType Conversion
Boolean Conversion:
    1=>true, 0=>false
    null=>false
    undefined=>false
    NaN=>false
    ""=>false
    []=>false
    {}=>false
    1.0=>true
    -1=>true //important
    -0=>false
    -1.0=>true

Number to string:
    let someNumber=14
    let someNumberString=string(someNumber)
    console.log(someNumberString) //14 ** we can see that the number is shown as same as 14 but actually it has been converted as to string, prven via checking its type
    console.log(typeof someNumberString) // shows as String

String to number:
    let someString="14"
    let someNumber=Number(someString)
    console.log(someNumber) //14
    console.log(typeof someNumber) // shows as Number
    let someString="14.5"
    let someNumber=Number(someString)
    console.log(someNumber) //14.5

--------------------------------------------------------------------------------------------------------------------------------
--Operations:
    // *********************** Operations ***********************

let value = 3
let negValue = -value
console.log(negValue);

console.log(2+2);
console.log(2-2);
console.log(2*2);
console.log(2**3);
console.log(2/3);
console.log(2%3);

let str1 = "hello"
let str2 = " hitesh"

let str3 = str1 + str2
// console.log(str3);

// console.log("1" + 2);
// console.log(1 + "2");
// console.log("1" + 2 + 2); 
// console.log(1 + 2 + "2");

// console.log( (3 + 4) * 5 % 3);

// console.log(+true);
// console.log(+"");

let num1, num2, num3

num1 = num2 = num3 = 2 + 2

let gameCounter = 100
++gameCounter;
console.log(gameCounter);//101

    Rules of conversion:
// consversion with substarction ** substarction doesnt bothered about any string it does its operation as usual
let n1 = 10
let n2 = "5"

console.log("substarction"); 
console.log(n1-n2); //5
console.log(n2-n1); //-5

console.log("Addition"); ** Addition has an condition, if 2 consecutive values will be taken then it always concantate the strings, wheresas if more than two values will be taken then it uses a precedence rule which means it checks the first value if its string then the whole concantetation will be done as string, if number then simple addition will take place
console.log(n1+n2); //105
console.log(n2+n1); //510

console.log("Addition with 3 value");
console.log("2"+1+1); //211 // iif string starts first then simple do all concantetaion
console.log(2+1+"1"); //31 // if num starts then simple addition takes place excluding string... that only concantates

console.log("substraction with 3 value");
console.log("2"-1-1); //0
console.log(2-1-"1"); //0

console.log("Multiplication conversion"); // Multiplication works the same as substraction
console.log("5"*2); //10
console.log(5*"2"); //10

console.log("5"*2*"10"); //100
console.log(5*"2"*10); //100

console.log("Division conversion"); // division works the same as multipliacion and substraction
console.log("5"/2); //2.5
console.log(5/"2"); //2.5

console.log("5"/2/"5"); //0.5
console.log(5/2/"5"); //0.5
// -------- comaprison operator------------
console.log(2>"1");// it actually works return as true
console.log(2>"2");// it actually works return as false

console.log(2=="2"); //true
console.log(2==="2"); //false

console.log(null>0); //false
console.log(null<0); //false
console.log(null>=0); // true ** The reason console.log(null >= 0) returns true is because of how JavaScript handles comparisons involving null. When null is compared to a number using operators like >= or <=, it is treated as if it were 0. This is known as type coercion, where JavaScript tries to convert the values to a compatible type for the comparison.

console.log(undefined>0); //false
console.log(undefined<0); //false
console.log(undefined>=0); //false
// ** Since undefined is not 0, undefined is the absence of value, since the memory/spac is been allocated in the memory itself


--------------------------------------------------------------------------------------------------------------------------------
--DataType Summary:
        In jsavaScript there are two type of DataType:
        1. Primitive DataType (passed by value)
        2. Non-Primitive DataType (passed by refrence)

    primitive values: => DataType
    1. Number    =>number
    2. String    =>String
    3. Boolean   =>boolean
    4. Null      =>object
    5. Undefined =>undefined
    6. Symbol    => Symbol
    7. BigInt    =>BigInt

    non-primitive:
    1. Array    =>object
    2. Object   =>object
    3. Function =>function **very imporatnt** 
                   function name() {
                    console.log("yo world");
                   }
                   console.log(typeof name()); //The reason console.log(typeof name()); shows undefined instead of a type is because the name function doesn't explicitly return a value. In JavaScript, if a function doesn't return a value, it defaults to returning undefined
                   console.log(typeof name); //this is the corect approach 

                    function name2() {
                    return 1
                    }
                    console.log(typeof name2()); // here we can observe that it return one since we have statically reaturn type as numb  

--------------------------------------------------------------------------------------------------------------------------------
--Stack VS Heap:
Stack: (primitive datatype)           
1. It is a LIFO (Last In First Out) data structure
2. It is used for storing local variables, function arguments, return values, and function calls
3. It is a memory space that is allocated and deallocated automatically by the JavaScript engine
4. It is faster and more efficient than the heap
5. It is used for storing primitive values and non-primitive values that are passed by value
6. It is not accessible directly from JavaScript code

Example:
    let name="vicky"
    console.log(name)//vicky
    let nameTwo=name
    console.log(nameTwo)//vicky

Heap: (NON-PRIMITIVE)
1. It is a dynamic memory allocation system
2. It is used for storing objects, arrays, and other non-primitive values that are passed
3. It is a memory space that is allocated and deallocated manually by the JavaScript engine
4. It is slower and less efficient than the stack
5. It is used for storing non-primitive values that are passed by reference
6. It is accessible directly from JavaScript code
7. It is used for storing objects, arrays, and other non-primitive values that are passed

Example:
    let userOne={
        name:"vicky",
        age:21
    }
    console.log(userOne.name)// vicky
    console.log(userOne.age) //21

    let userTwo=userOne
    userTwo.name="legend"
    userTwo.age="22"
    console.log(userOne.name)// vicky
    console.log(userOne.age) //21
    ** jsut the refrence had been passed, not the copy of the variable

--------------------------------------------------------------------------------------------------------------------------------
--String:
1. Strings are immutable in JavaScript
2. Strings are primitive data types
3. Strings are used for storing text data
4. Strings are used for concatenation, slicing, and other string operations
5. Strings are used for regular expressions
6. Strings are used for template literals
7. Strings are used for string interpolation

** Two way of declaring string is:
1. let name="Hello from first string" // the simple and the best approach
2. let name=new String("Hello from second string")

let string ="vickyacharjee"
let s=stringTwo=" vicky acharjee"

    // prototype
        // toUpperCase
        console.log( string.toUpperCase()); //VICKYACHARJEE

        // toLowerCase
        console.log(string.toLowerCase()); //vickyacharjee
        // charAt
        console.log(string.charAt(2)); // c
        // indexOf
        console.log(string.indexOf('a')); // 5 ** one thing might be wondering in ur mind, if i have the same letter, occuring multiple time in a string... it simply returns the first letter as using precedence rulefrom lef to right
        // lastIndexOf
        console.log(string.lastIndexOf('a')); // 5 ** same as index of only but it uses precedence rule from left to right

        // trim
        console.log(stringTwo.trim()); // vickyacharjee

        // trimLeft
        console.log(stringTwo.trimLeft()); // vickyacharjee **trims only from the left

        // trimRight
        console.log(stringTwo.trimRight()); // vicky acharjee **trims only from the right

        // split
        console.log(stringTwo.split(' ')); // ['vicky', 'acharjee'] **splits it into an array as per ur desired, just via providing which to split here in our case we used split(" ")...that means it it spliting into an array via checking through array

        //substring
        console.log(string.substring(0,2)); 

        //slice ** works very similar to substring, but the extra added feature is it can starts from reverse too... which basically starts from -1 and goes upto
        let exampleSlice=string.slice(-3,-1) // we can observe it using reserve order
        console.log(exampleSlice);

        // replaceWith
        console.log(stringTwo.replace('vicky', 'vickyacharjee'));  // vickyacharjee acharjee


--------------------------------------------------------------------------------------------------------------------------------
--Properties and Functions:

In JavaScript, a property is a value associated with an object. It's a characteristic or an attribute of an object that can be accessed using dot notation or bracket notation. Properties are not functions, and they don't perform any actions. They simply hold a value.

    Example:

    javascript
    Edit
    Copy code
    let person = {
    name: 'John',
    age: 30
    };

    console.log(person.name); // outputs "John"
    console.log(person.age); // outputs 30

In this example, name and age are properties of the person object.

Functions (or Methods)

A function, also known as a method, is a block of code that performs a specific action. It's a set of instructions that can be executed when called. Functions can take arguments, return values, and modify the state of an object.

Example:

    javascript
    Edit
    Copy code
    let person = {
    name: 'John',
    age: 30,
    greet: function() {
        console.log('Hello, my name is ' + this.name);
    }
    };

    person.greet(); // outputs "Hello, my name is John"
In this example, greet is a function (or method) of the person object.

Key differences

Here are the key differences between properties and functions:

Parentheses: When accessing a property, you don't use parentheses. When calling a function, you use parentheses to pass arguments (even if there are no arguments).
Action: Properties don't perform any actions. Functions execute a block of code to perform a specific action.
Return value: Properties return their value. Functions can return a value, but it's not required.
Now, let's look at your original code:

--------------------------------------------------------------------------------------------------------------------------------
--Numers and Math:
1. Numbers are used for mathematical operations
2. Numbers are used for exponentiation
3. Numbers are used for modulus
4. Numbers are used for rounding
5. Numbers are used for absolute value
6. Numbers are used for square root
7. Numbers are used for logarithm
8. Numbers are used for exponentiation
9. Numbers are used for power
10. Numbers are used for random number generation

    **Number can be declared in 2 ways:
    1. let num = 10; //the simple way
    2. let num = Number(10);  //the other way statically providing its type

    let score=12
let scoreTwo=1000000
console.log(score);
console.log(typeof score);

let scoreNo=Number(12)
console.log(scoreNo);
console.log(typeof scoreNo);

console.log( score.toString());// score datatype changes to string, that only for this particular line only it had been reflected.
//console.log( typeof score); // There if we will check its type then it asusual returns number
console.log(score.toString().length);

console.log(score.toFixed(2)); //12.00
console.log(score.toFixed(1)); //12.0

console.log(score.toPrecision(3)); //12.0

console.log(scoreTwo.toLocaleString());// by default JS gives USA counting format
console.log(scoreTwo.toLocaleString('en-IN'));// for making counting at indian format ... we need to include in the aparameter as "en_IN"

// Maths:
// Math is a predefined JS library
console.log(Math.abs(-1)); // provides absolute value from negative to posiutive only
console.log(Math.ceil(1.2)); // provides the smallest integer greater than or equal to the provided number
console.log(Math.floor(1.2)); // provides the largest integer less than or equal to the provided number
console.log(Math.max(1,2,3,4,5)); // provides the largest number
console.log(Math.min(1,2,3,4,5)); // provides the smallest number
console.log(Math.pow(2,3)); // provides the power of the number 
console.log(Math.sqrt(4)); // provides the square root of the number // ans as 2
console.log(Math.PI); // provides the value of PI i.e 3.14
console.log(Math.E); // provides the value of E i.e 2.718
console.log(Math.round(1.2)); // provides the nearest integer to the number
console.log(Math.trunc(1.2)); // provides the integer part of the number
console.log(Math.sign(1.2)); // provides the sign of the number
console.log(Math.sign(-1.2)); // provides the sign of the number
console.log(Math.sign(0)); // provides the sign of the number

console.log(Math.random()); // provides the random number between 0 and 1
// adding plus 1 so that the random number minimum value would be 1
console.log(Math.random()+1);
// making the range btw 1 to 10
console.log(Math.random()*10+1);
// now avoiding decimal via ceil or floor
console.log(Math.floor(Math.random()*10+1));

// Important formulae: hre we can privide min and max value manually
let min=10
let max=20
console.log(Math.floor(Math.random()*(max-min+1)+min));

**Important**
const num=new Number(12)
console.log(typeof num); // its type is object since we used new keyword above while declaring so it created a number constructor
num.a="vick"
console.log(num); // [Number: 12] { a: 'vick' }

        Here's what's happening:

        [Number: 12] is the internal representation of the num object, indicating that it's a Number object with an internal value of 12.
        a: 'vick' is the additional property you added to the num object, with key a and value "vick".

--------------------------------------------------------------------------------------------------------------------------------
-- Time and Date:
// Date is a predefined JS library
// the date datatype of date is object

The way to create date object is:
    let date=new Date()



let date=new Date();
console.log(date); //2024-09-06T10:25:52.010Z
console.log(date.toString()); //Fri Sep 06 2024 15:55:52 GMT+0530 (India Standard Time)
console.log(date.toDateString()); // Fri Sep 06 2024
console.log(date.toLocaleString()); //9/6/2024, 3:55:52 PM
console.log(typeof date); //object

//checking with arbitary date
let dateOne=new Date("01-14,2023")
console.log(dateOne); //2023-01-13T18:30:00.000Z

let stampDate= Date.now()
console.log(stampDate); //1725618352032
console.log(dateOne.getTime()); //1673634600000

//conveting into seconds
console.log(Math.floor(Date.now()/1000)); //1725618352

// customising the time and date
let dateTwo=new Date();
dateTwo.toLocaleString('default',{
        weekday: 'long',
})
console.log(dateTwo); //2024-09-06T10:25:52.033Z

--------------------------------------------------------------------------------------------------------------------------------
-- Property VS prototype
In JavaScript, property and prototype are two related but distinct concepts.

Property: A property is a key-value pair that is associated with an object. It's a way to attach a value to an object using a specific key or name. Properties can be thought of as variables that are attached to an object. For example:

    Example:
    const person = { name: 'John', age: 30 };
    In this example, name and age are properties of the person object.

Prototype: A prototype, on the other hand, is an object that is used as a blueprint or a template for creating other objects. When you create an object, it inherits properties and behavior from its prototype. In JavaScript, every object has a prototype, which is an internal reference to another object.

Here's an example:

    Example:
    function Animal() {}
    Animal.prototype.sound = function() { console.log('The animal makes a sound.'); };

    const dog = new Animal();
    dog.sound(); // Output: The animal makes a sound.
    In this example, Animal is a constructor function, and Animal.prototype is the prototype object. The sound method is a property of the prototype object. When we create a new object dog using the Animal constructor, it inherits the sound method from the prototype.

Key differences:
A property is a key-value pair attached to an object, while a prototype is an object that serves as a blueprint for creating other objects.
Properties are specific to an object, while a prototype is shared among multiple objects.
Properties are typically used to store data, while prototypes are used to define behavior and inheritance.
Would you like me to elaborate on this topic or provide more examples?

--------------------------------------------------------------------------------------------------------------------------------
--Array:

JavaScript arrays are a type of object that can store multiple values of any data type. 
Here are some key points about JavaScript arrays:
1. Arrays are zero-indexed, meaning the first element is at index 0.
2. Arrays can store values of any data type, including strings, numbers, booleans, objects.
3. Arrays can be created using the array literal syntax
4. Arrays can be created using the Array constructor
    
    Example 1: Creating an empty array
        let arr = new Array();
        console.log(arr);  // Output: []
        Example 2: Creating an array with a specific number of empty slots
        If you pass a single numeric argument to the Array constructor, it creates an array with that number of empty slots.

    Exmaple 2: Creating an array and reserving 3 empty items spaces   
        let arr = new Array(3);
        console.log(arr);  // Output: [ <3 empty items> ]
        Example 3: Creating an array with initial values
        You can pass multiple arguments to the Array constructor to create an array with the specified values.

    Example 3: creating and declaring an array
        let arr = new Array(1, 2, 3);
        console.log(arr);  // Output: [1, 2, 3]
        
        Note:
        It's generally more common to use the array literal syntax ([]) instead of the Array constructor due to its simplicity and clarity.
            Example:
            let arr = [1, 2, 3];
            console.log(arr);  // Output: [1, 2, 3]

5. Arrays have several built-in methods for manipulating and accessing their elements.
6. Arrays can be iterated over using a for loop or the forEach method.
7. Arrays can be sliced and spliced to add or remove elements.
8. Arrays can be sorted and reversed.
9. Arrays can be used as a stack or a queue.
10. Arrays can be used to store and manipulate large amounts of data.
Here are some examples of array methods:
Example:

const numbers = [1, 2, 3, 4, 5];
numbers.push(6); // adds 6 to the end of the array
numbers.pop(); // removes the last element from the array
numbers.shift(); // removes the first element from the array
numbers.unshift(0); // adds 0 to the beginning of the array, the bigegst flaws of using unshift is it changes the index alignment
numbers.indexOf(3); // L ot R returns the index as  2, if not present then, it results as -1 always
numbers.lastIndexOf(3); // R to L returns the index of the last occurrence of idex postion as 2
numbers.includes(3); // returns true if 3 is in the array, false otherwise //boolean as reults
numbers.join(','); // returns a string as datatype, containing all elements of the array, separated by commas ....note not only comma it can return variety such as , . : { } [] () * etc etc

    slice and splice:
         //slice 
         const array=[1,2,3,4,5]
         console.log(array); //[1,2,3,4,5]
         const sliceArray=array.slice(1,3)
         console.log(sliceArray); //[2, 3] // it basically extracts the 1 step lees than the given range
         console.log(array); //[1,2,3,4,5] // we can observe that there is not change in the amin array variable

        //splice
        const array=[1,2,3,4,5]
        console.log(array); //[1,2,3,4,5]
        const spliceArray=array.splice(1,3)
        console.log(spliceArray); //[2, 3, 4] // generally for the sake of sying it gives the until the last specified range specified by the user
        console.log(array); //[1, 5] // we can observe that there is a change in the main root array.... ***IMPORTANT*** Mark it that, any changes made on the leaf array via splice, then it directly reflects to the root array

    Array: part 2 (array mainpulation)
     // issue with push()
    const myArr1=[1,2,3,4,5]
    const myArr2=[6,7,8,9,10]
    myArr1.push(myArr2)
    console.log(myArr1) //[ 1, 2, 3, 4, 5, [ 6, 7, 8, 9, 10 ] ] we cam observe that whole myArr2 is taken as as element of myArr1 :: this whole [ 6, 7, 8, 9, 10 ] is taken as 6th lement as myArr1 
    // so inorder to acces the elemnt 7: 
    console.log(myArr1[5][1])


    // issue with concat() // the diffrence makes here from push() is  in concat we need to store to another variable for displaying unlike in push() we can directly access without taking new variable
    const myArr1=[1,2,3,4,5]
    const myArr2=[6,7,8,9,10]
    const result=myArr1.concat(myArr2)
    console.log(result[7]) 
    // Note: concat() is the best appraoch among 2 since, it concantate exactly at the end of new array at the last of previous one

    // Alternate to concat() is using spread operator, since in mordern code we see this alot:)  
    const myArr1=[1,2,3,4,5]
    const myArr2=[6,7,8,9,10]
    const result=[...myArr1,...myArr2] // we can even add more array to it
    console.log(result); //[1,2,3,4,5,6,7,8,9,10]

    // complex nested array
    const ar1 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
    console.log(ar1[2][2][2][1]); // outputs 10

    // using via flat all the nested array becomes an consecutive individual element
    const result=ar1.flat(Infinity)
    console.log(result); [1,2,3,4,5,6,7,8,9,10]

    // isArray => if variable is array then, returns as True else False
    const vicky=[1,2]
    const acharjee=1;
    console.log(Array.isArray(acharjee)); //false
    console.log(Array.isArray(vicky)); //false

    //from method
    const res=Array.from("vicky")
    console.log(res); // converts string into array element as : [ 'v', 'i', 'c', 'k', 'y' ]

    // from as object
    const obj={name:"vicky",age:25}
    const res2=Array.from(obj)
    console.log(res2); // outputs as error

    // of method
    let score1=100
    let score2=200
    let score3=300
    console.log(Array.of(score1,score2,score3)); //[ 100, 200, 300 ] //of operator adds all the variable in a single array one by one

    //There's a way to access string as array index
    console.log('2 want pizza'[0]); // returns 2
    console.log('I want pizza'[4]); // returns n

--------------------------------------------------------------------------------------------------------------------------------
--Objects: 
    // An object is an important topic in jsavaScript
    // An object is a collection of key-value pairs
    // An object is a collection of properties
    // An object is a collection of methods
    // An object is a collection of Functions
    // An object is a collection of variables
    // An object is a collection of data
    // An object is a collection of information
    
        //SingleTon
        //Object Literals

        // way to create Objects
        //1. Object Literal
        let obj1={
            name:"vicky",
            class:"btch"
            }
            // ** NOTE: all the key in objects are acceprted as string, if in genral we declare it normal variable then also internally it converts and accept as String
            // There are two ways to access objects
            //1. Dot Notation
            // console.log(obj1.name);// vicky
            //2. Bracket Notation
            // console.log(obj1['name']);// vicky
            //  ** NOTE: . notation is kinda new approach where as, using square brackets used as main scenario approach
            //  ** NOTE: we can use bracket notation with variables also
            //  ** NOTE: if we need  valid reason of maiking squate braces much added advantages from . notation is:

            // creation of symbol variable
            let symbol=Symbol("keyOne")
            // creating new object for symbol example
            const mySym={
               "vic Name":"vicky",
                age:21,
                [symbol]:"thisIsKey"
            }
            // log using . notation
            console.log(mySym.symbol)// thisIsKey
            // So using dot notation we got the result but partially since ithis is not the correct approach 

            // log using bracket notation
            console.log(mySym[symbol])// thisIsKey ** correct approach

            //another very very imporatnt this is, if bychnace the key in object is within string manually " " then there is no chace for accessing using dont notation, there we need to use [] braces
            // Example taking the same object from above
            
            // with dot notation
            console.log(mySym.vic name);// throws an error since there should be no space in variable naming
            // with bracket notation
            console.log(mySym["vic name"]);// vicky.... since using [] we can access by embedding it into a string
    
    // Freezing an object
            // ** NOTE: we can freeze an object using Object.freeze() method
            // any cahneges made after the declaration of freeze method, will not make anychanges further on
            const obj2={
            name:"vicky", // type string
            age:21, //type string
            isLoggedIn:true, //type boolean
            counLogSession:["monday","wednesday"], //type array
            }
            obj2.name="vicky-acharjee"
            console.log(obj2.name); // vicky-acharjee
            // now we will freeze
            Object.freeze(obj2)
            obj2.name="vicky-acharjee-2"// no changes had been made here since the obj2 has already been freezed
            console.log(obj2.name); // vicky-acharjee                         

    // Methods or Function in objects:
        let myObj={
            name:"vicky"
            greet:function(){
                console.log("Hey there everyone")
            }
        }
        myObj.greet()// Hey there everyone
    
    // we can also define methods using arrow functions
        let myObj2={
            name:"vicky",
            greet:()=>{
                console.log("Hey there everyone from arrow functions")
            }
        }
        myObj2.greet()// Hey there everyone from arrow functons

    // using this method,
    // using this method we ill be accessible to get any refrence from the object
    // Example
        let thisObj={
            name:"vicky",
            greet:function(){
                console.log("hi "+this.vicky) // here we used as this to get the refrence from the object
            }
        }
       ** What is the purpose of the “this” keyword in JavaScript?
       ** The this keyword refers to the object that is executing the current function or method.
          It allows access to object properties and methods within the context of that object
    // NOTE: *** Very Very important, using arrow functions we are accessed to use .this keyword... it will throw an error 

                all functons line up:
                const funobj={
                name:"vicky",
                greet:function(){
                    console.log("hey there everyone");
                },
                greet2:()=>{
                    console.log("hey from arrow functions");
                },
                greet3(){
                    console.log("hey from "+this.name)
             }
            }
             console.log(funobj.greet()); // noob approach
             funobj.greet2();
             funobj.greet3();
        //Note:
        if we will console.log() only the function name, not using() then,
        it will return the function itself, not the output of the function
        Example:
        console.log(funobj.greet); // it will return function 
        // this: [Function: greet]

--------------------------------------------------------------------------------------------------------------------------------
--Difference between between function and method:

In JavaScript, the terms "function" and "method" are often used interchangeably, but there is a subtle difference between them.

Function: A function is a block of code that can be called multiple times from different parts of your program. 
          It is a self-contained piece of code that takes in arguments, executes a set of statements, and returns a value. 
          Functions are not part of an object and are defined independently.
            //Example
            function add(x, y) {
            return x + y;
            }

Method: A method is a function that is part of an object.
        It is a function that is defined inside an object and is used to perform an action on that object.
        Methods are called on an instance of an object, and they have access to the object's properties and other methods.
            //Example
            const person = {
            name: 'John',
            sayHello: function() {
                console.log(`Hello, my name is ${this.name}!`);
            }
            };
            person.sayHello(); // Output: Hello, my name is John!
    
    To summarize:
    A function is a standalone block of code that can be called independently.
    A method is a function that is part of an object and is used to perform an action on that object.        

--------------------------------------------------------------------------------------------------------------------------------







            









