
--let,var,const

const is very staraight forward meaning thats once the value is been declared then it cant be changed further on.

var is a bit tricky it can be changed anytime, the state changes and it reflects to all the all the variable with same name. 
This was the major issue using var.

let is similar to var but it has one difference it cant be changed once it is declared.
** let resolves this issue via scoping

--------------------------------------------------------------------------------------------------------------------------------

-- DataType and Ecma
// number => 2 to power 53  type is number
// bigint type is bugint
// string => "" type is string
// boolean => true/false type is boolean
// null => standalone value type is object
// undefined => tye is undefined
// symbol => unique type is symbol

undefined
Type: undefined is its own primitive type.
Meaning: It indicates that a variable has been declared but has not yet been assigned a value. It is also the default return value of functions that don't explicitly return something.
When to Use: Typically, you don't explicitly assign undefined to a variable. It's mainly used by JavaScript internally or to check if a variable has been initialized.

null
Type: null is an object (this is a quirk in JavaScript).
Meaning: It represents the intentional absence of any object value. It's often used to indicate that a variable should have no value.
When to Use: You can assign null to a variable when you want to explicitly indicate that it should be empty or have no value.
example: clearing the object value
         let obj={
            name:"John",
            age:21
         }
         obj=null;  // here we can observe that the object is ben cleared

         another example is:
         take tempearure as an example, if by chance the temperature is reset then 0 cant be the reset value since 0 is considered as a temperature value so here instead we use NULL
 
 ***  "use strict"; // treat all JS code as newer version       

--------------------------------------------------------------------------------------------------------------------------------
--DataType Conversion
Boolean Conversion:
    1=>true, 0=>false
    null=>false
    undefined=>false
    NaN=>false
    ""=>false
    []=>false
    {}=>false
    1.0=>true
    -1=>true //important
    -0=>false
    -1.0=>true

Number to string:
    let someNumber=14
    let someNumberString=string(someNumber)
    console.log(someNumberString) //14 ** we can see that the number is shown as same as 14 but actually it has been converted as to string, prven via checking its type
    console.log(typeof someNumberString) // shows as String

String to number:
    let someString="14"
    let someNumber=Number(someString)
    console.log(someNumber) //14
    console.log(typeof someNumber) // shows as Number
    let someString="14.5"
    let someNumber=Number(someString)
    console.log(someNumber) //14.5

--------------------------------------------------------------------------------------------------------------------------------
--Operations:
    // *********************** Operations ***********************

let value = 3
let negValue = -value
console.log(negValue);

console.log(2+2);
console.log(2-2);
console.log(2*2);
console.log(2**3);
console.log(2/3);
console.log(2%3);

let str1 = "hello"
let str2 = " hitesh"

let str3 = str1 + str2
// console.log(str3);

// console.log("1" + 2);
// console.log(1 + "2");
// console.log("1" + 2 + 2); 
// console.log(1 + 2 + "2");

// console.log( (3 + 4) * 5 % 3);

// console.log(+true);
// console.log(+"");

let num1, num2, num3

num1 = num2 = num3 = 2 + 2

let gameCounter = 100
++gameCounter;
console.log(gameCounter);//101

    Rules of conversion:
// consversion with substarction ** substarction doesnt bothered about any string it does its operation as usual
let n1 = 10
let n2 = "5"

console.log("substarction"); 
console.log(n1-n2); //5
console.log(n2-n1); //-5

console.log("Addition"); ** Addition has an condition, if 2 consecutive values will be taken then it always concantate the strings, wheresas if more than two values will be taken then it uses a precedence rule which means it checks the first value if its string then the whole concantetation will be done as string, if number then simple addition will take place
console.log(n1+n2); //105
console.log(n2+n1); //510

console.log("Addition with 3 value");
console.log("2"+1+1); //211 // iif string starts first then simple do all concantetaion
console.log(2+1+"1"); //31 // if num starts then simple addition takes place excluding string... that only concantates

console.log("substraction with 3 value");
console.log("2"-1-1); //0
console.log(2-1-"1"); //0

console.log("Multiplication conversion"); // Multiplication works the same as substraction
console.log("5"*2); //10
console.log(5*"2"); //10

console.log("5"*2*"10"); //100
console.log(5*"2"*10); //100

console.log("Division conversion"); // division works the same as multipliacion and substraction
console.log("5"/2); //2.5
console.log(5/"2"); //2.5

console.log("5"/2/"5"); //0.5
console.log(5/2/"5"); //0.5
// -------- comaprison operator------------
console.log(2>"1");// it actually works return as true
console.log(2>"2");// it actually works return as false

console.log(2=="2"); //true
console.log(2==="2"); //false

console.log(null>0); //false
console.log(null<0); //false
console.log(null>=0); // true ** The reason console.log(null >= 0) returns true is because of how JavaScript handles comparisons involving null. When null is compared to a number using operators like >= or <=, it is treated as if it were 0. This is known as type coercion, where JavaScript tries to convert the values to a compatible type for the comparison.

console.log(undefined>0); //false
console.log(undefined<0); //false
console.log(undefined>=0); //false
// ** Since undefined is not 0, undefined is the absence of value, since the memory/spac is been allocated in the memory itself


--------------------------------------------------------------------------------------------------------------------------------
--DataType Summary:
        In jsavaScript there are two type of DataType:
        1. Primitive DataType (passed by value)
        2. Non-Primitive DataType (passed by refrence)

    primitive values: => DataType
    1. Number    =>number
    2. String    =>String
    3. Boolean   =>boolean
    4. Null      =>object
    5. Undefined =>undefined
    6. Symbol    => Symbol
    7. BigInt    =>BigInt

    non-primitive:
    1. Array    =>object
    2. Object   =>object
    3. Function =>function **very imporatnt** 
                   function name() {
                    console.log("yo world");
                   }
                   console.log(typeof name()); //The reason console.log(typeof name()); shows undefined instead of a type is because the name function doesn't explicitly return a value. In JavaScript, if a function doesn't return a value, it defaults to returning undefined
                   console.log(typeof name); //this is the corect approach 

                    function name2() {
                    return 1
                    }
                    console.log(typeof name2()); // here we can observe that it return one since we have statically reaturn type as numb  

--------------------------------------------------------------------------------------------------------------------------------
--Stack VS Heap:
Stack: (primitive datatype)           
1. It is a LIFO (Last In First Out) data structure
2. It is used for storing local variables, function arguments, return values, and function calls
3. It is a memory space that is allocated and deallocated automatically by the JavaScript engine
4. It is faster and more efficient than the heap
5. It is used for storing primitive values and non-primitive values that are passed by value
6. It is not accessible directly from JavaScript code

Example:
    let name="vicky"
    console.log(name)//vicky
    let nameTwo=name
    console.log(nameTwo)//vicky

Heap: (NON-PRIMITIVE)
1. It is a dynamic memory allocation system
2. It is used for storing objects, arrays, and other non-primitive values that are passed
3. It is a memory space that is allocated and deallocated manually by the JavaScript engine
4. It is slower and less efficient than the stack
5. It is used for storing non-primitive values that are passed by reference
6. It is accessible directly from JavaScript code
7. It is used for storing objects, arrays, and other non-primitive values that are passed

Example:
    let userOne={
        name:"vicky",
        age:21
    }
    console.log(userOne.name)// vicky
    console.log(userOne.age) //21

    let userTwo=userOne
    userTwo.name="legend"
    userTwo.age="22"
    console.log(userOne.name)// vicky
    console.log(userOne.age) //21
    ** jsut the refrence had been passed, not the copy of the variable

--------------------------------------------------------------------------------------------------------------------------------
--String:
1. Strings are immutable in JavaScript
2. Strings are primitive data types
3. Strings are used for storing text data
4. Strings are used for concatenation, slicing, and other string operations
5. Strings are used for regular expressions
6. Strings are used for template literals
7. Strings are used for string interpolation

** Two way of declaring string is:
1. let name="Hello from first string" // the simple and the best approach
2. let name=new String("Hello from second string")

let string ="vickyacharjee"
let s=stringTwo=" vicky acharjee"

    // prototype
        // toUpperCase
        console.log( string.toUpperCase()); //VICKYACHARJEE

        // toLowerCase
        console.log(string.toLowerCase()); //vickyacharjee
        // charAt
        console.log(string.charAt(2)); // c
        // indexOf
        console.log(string.indexOf('a')); // 5 ** one thing might be wondering in ur mind, if i have the same letter, occuring multiple time in a string... it simply returns the first letter as using precedence rulefrom lef to right
        // lastIndexOf
        console.log(string.lastIndexOf('a')); // 5 ** same as index of only but it uses precedence rule from left to right

        // trim
        console.log(stringTwo.trim()); // vickyacharjee

        // trimLeft
        console.log(stringTwo.trimLeft()); // vickyacharjee **trims only from the left

        // trimRight
        console.log(stringTwo.trimRight()); // vicky acharjee **trims only from the right

        // split
        console.log(stringTwo.split(' ')); // ['vicky', 'acharjee'] **splits it into an array as per ur desired, just via providing which to split here in our case we used split(" ")...that means it it spliting into an array via checking through array

        //substring
        console.log(string.substring(0,2)); 

        //slice ** works very similar to substring, but the extra added feature is it can starts from reverse too... which basically starts from -1 and goes upto
        let exampleSlice=string.slice(-3,-1) // we can observe it using reserve order
        console.log(exampleSlice);

        // replaceWith
        console.log(stringTwo.replace('vicky', 'vickyacharjee'));  // vickyacharjee acharjee


--------------------------------------------------------------------------------------------------------------------------------
--Properties and Functions:

In JavaScript, a property is a value associated with an object. It's a characteristic or an attribute of an object that can be accessed using dot notation or bracket notation. Properties are not functions, and they don't perform any actions. They simply hold a value.

    Example:

    javascript
    Edit
    Copy code
    let person = {
    name: 'John',
    age: 30
    };

    console.log(person.name); // outputs "John"
    console.log(person.age); // outputs 30

In this example, name and age are properties of the person object.

Functions (or Methods)

A function, also known as a method, is a block of code that performs a specific action. It's a set of instructions that can be executed when called. Functions can take arguments, return values, and modify the state of an object.

Example:

    javascript
    Edit
    Copy code
    let person = {
    name: 'John',
    age: 30,
    greet: function() {
        console.log('Hello, my name is ' + this.name);
    }
    };

    person.greet(); // outputs "Hello, my name is John"
In this example, greet is a function (or method) of the person object.

Key differences

Here are the key differences between properties and functions:

Parentheses: When accessing a property, you don't use parentheses. When calling a function, you use parentheses to pass arguments (even if there are no arguments).
Action: Properties don't perform any actions. Functions execute a block of code to perform a specific action.
Return value: Properties return their value. Functions can return a value, but it's not required.
Now, let's look at your original code:

--------------------------------------------------------------------------------------------------------------------------------
--Numers and Math:
1. Numbers are used for mathematical operations
2. Numbers are used for exponentiation
3. Numbers are used for modulus
4. Numbers are used for rounding
5. Numbers are used for absolute value
6. Numbers are used for square root
7. Numbers are used for logarithm
8. Numbers are used for exponentiation
9. Numbers are used for power
10. Numbers are used for random number generation

    **Number can be declared in 2 ways:
    1. let num = 10; //the simple way
    2. let num = Number(10);  //the other way statically providing its type

    let score=12
let scoreTwo=1000000
console.log(score);
console.log(typeof score);

let scoreNo=Number(12)
console.log(scoreNo);
console.log(typeof scoreNo);

console.log( score.toString());// score datatype changes to string, that only for this particular line only it had been reflected.
//console.log( typeof score); // There if we will check its type then it asusual returns number
console.log(score.toString().length);

console.log(score.toFixed(2)); //12.00
console.log(score.toFixed(1)); //12.0

console.log(score.toPrecision(3)); //12.0

console.log(scoreTwo.toLocaleString());// by default JS gives USA counting format
console.log(scoreTwo.toLocaleString('en-IN'));// for making counting at indian format ... we need to include in the aparameter as "en_IN"

// Maths:
// Math is a predefined JS library
console.log(Math.abs(-1)); // provides absolute value from negative to posiutive only
console.log(Math.ceil(1.2)); // provides the smallest integer greater than or equal to the provided number
console.log(Math.floor(1.2)); // provides the largest integer less than or equal to the provided number
console.log(Math.max(1,2,3,4,5)); // provides the largest number
console.log(Math.min(1,2,3,4,5)); // provides the smallest number
console.log(Math.pow(2,3)); // provides the power of the number 
console.log(Math.sqrt(4)); // provides the square root of the number // ans as 2
console.log(Math.PI); // provides the value of PI i.e 3.14
console.log(Math.E); // provides the value of E i.e 2.718
console.log(Math.round(1.2)); // provides the nearest integer to the number
console.log(Math.trunc(1.2)); // provides the integer part of the number
console.log(Math.sign(1.2)); // provides the sign of the number
console.log(Math.sign(-1.2)); // provides the sign of the number
console.log(Math.sign(0)); // provides the sign of the number

console.log(Math.random()); // provides the random number between 0 and 1
// adding plus 1 so that the random number minimum value would be 1
console.log(Math.random()+1);
// making the range btw 1 to 10
console.log(Math.random()*10+1);
// now avoiding decimal via ceil or floor
console.log(Math.floor(Math.random()*10+1));

// Important formulae: hre we can privide min and max value manually
let min=10
let max=20
console.log(Math.floor(Math.random()*(max-min+1)+min));

**Important**
const num=new Number(12)
console.log(typeof num); // its type is object since we used new keyword above while declaring so it created a number constructor
num.a="vick"
console.log(num); // [Number: 12] { a: 'vick' }

        Here's what's happening:

        [Number: 12] is the internal representation of the num object, indicating that it's a Number object with an internal value of 12.
        a: 'vick' is the additional property you added to the num object, with key a and value "vick".

--------------------------------------------------------------------------------------------------------------------------------
-- Time and Date:
// Date is a predefined JS library
// the date datatype of date is object

The way to create date object is:
    let date=new Date()



let date=new Date();
console.log(date); //2024-09-06T10:25:52.010Z
console.log(date.toString()); //Fri Sep 06 2024 15:55:52 GMT+0530 (India Standard Time)
console.log(date.toDateString()); // Fri Sep 06 2024
console.log(date.toLocaleString()); //9/6/2024, 3:55:52 PM
console.log(typeof date); //object

//checking with arbitary date
let dateOne=new Date("01-14,2023")
console.log(dateOne); //2023-01-13T18:30:00.000Z

let stampDate= Date.now()
console.log(stampDate); //1725618352032
console.log(dateOne.getTime()); //1673634600000

//conveting into seconds
console.log(Math.floor(Date.now()/1000)); //1725618352

// customising the time and date
let dateTwo=new Date();
dateTwo.toLocaleString('default',{
        weekday: 'long',
})
console.log(dateTwo); //2024-09-06T10:25:52.033Z

--------------------------------------------------------------------------------------------------------------------------------
-- Property VS prototype
In JavaScript, property and prototype are two related but distinct concepts.

Property: A property is a key-value pair that is associated with an object. It's a way to attach a value to an object using a specific key or name. Properties can be thought of as variables that are attached to an object. For example:

    Example:
    const person = { name: 'John', age: 30 };
    In this example, name and age are properties of the person object.

Prototype: A prototype, on the other hand, is an object that is used as a blueprint or a template for creating other objects. When you create an object, it inherits properties and behavior from its prototype. In JavaScript, every object has a prototype, which is an internal reference to another object.

Here's an example:

    Example:
    function Animal() {}
    Animal.prototype.sound = function() { console.log('The animal makes a sound.'); };

    const dog = new Animal();
    dog.sound(); // Output: The animal makes a sound.
    In this example, Animal is a constructor function, and Animal.prototype is the prototype object. The sound method is a property of the prototype object. When we create a new object dog using the Animal constructor, it inherits the sound method from the prototype.

Key differences:
A property is a key-value pair attached to an object, while a prototype is an object that serves as a blueprint for creating other objects.
Properties are specific to an object, while a prototype is shared among multiple objects.
Properties are typically used to store data, while prototypes are used to define behavior and inheritance.
Would you like me to elaborate on this topic or provide more examples?

--------------------------------------------------------------------------------------------------------------------------------
--Array:

JavaScript arrays are a type of object that can store multiple values of any data type. 
Here are some key points about JavaScript arrays:
1. Arrays are zero-indexed, meaning the first element is at index 0.
2. Arrays can store values of any data type, including strings, numbers, booleans, objects.
3. Arrays can be created using the array literal syntax
4. Arrays can be created using the Array constructor
    
    Example 1: Creating an empty array
        let arr = new Array();
        console.log(arr);  // Output: []
        Example 2: Creating an array with a specific number of empty slots
        If you pass a single numeric argument to the Array constructor, it creates an array with that number of empty slots.

    Exmaple 2: Creating an array and reserving 3 empty items spaces   
        let arr = new Array(3);
        console.log(arr);  // Output: [ <3 empty items> ]
        Example 3: Creating an array with initial values
        You can pass multiple arguments to the Array constructor to create an array with the specified values.

    Example 3: creating and declaring an array
        let arr = new Array(1, 2, 3);
        console.log(arr);  // Output: [1, 2, 3]
        
        Note:
        It's generally more common to use the array literal syntax ([]) instead of the Array constructor due to its simplicity and clarity.
            Example:
            let arr = [1, 2, 3];
            console.log(arr);  // Output: [1, 2, 3]

5. Arrays have several built-in methods for manipulating and accessing their elements.
6. Arrays can be iterated over using a for loop or the forEach method.
7. Arrays can be sliced and spliced to add or remove elements.
8. Arrays can be sorted and reversed.
9. Arrays can be used as a stack or a queue.
10. Arrays can be used to store and manipulate large amounts of data.
Here are some examples of array methods:
Example:

const numbers = [1, 2, 3, 4, 5];
numbers.push(6); // adds 6 to the end of the array
numbers.pop(); // removes the last element from the array
numbers.shift(); // removes the first element from the array
numbers.unshift(0); // adds 0 to the beginning of the array, the bigegst flaws of using unshift is it changes the index alignment
numbers.indexOf(3); // L ot R returns the index as  2, if not present then, it results as -1 always
numbers.lastIndexOf(3); // R to L returns the index of the last occurrence of idex postion as 2
numbers.includes(3); // returns true if 3 is in the array, false otherwise //boolean as reults
numbers.join(','); // returns a string as datatype, containing all elements of the array, separated by commas ....note not only comma it can return variety such as , . : { } [] () * etc etc

    slice and splice:
         //slice 
         const array=[1,2,3,4,5]
         console.log(array); //[1,2,3,4,5]
         const sliceArray=array.slice(1,3)
         console.log(sliceArray); //[2, 3] // it basically extracts the 1 step lees than the given range
         console.log(array); //[1,2,3,4,5] // we can observe that there is not change in the amin array variable

        //splice
        const array=[1,2,3,4,5]
        console.log(array); //[1,2,3,4,5]
        const spliceArray=array.splice(1,3)
        console.log(spliceArray); //[2, 3, 4] // generally for the sake of sying it gives the until the last specified range specified by the user
        console.log(array); //[1, 5] // we can observe that there is a change in the main root array.... ***IMPORTANT*** Mark it that, any changes made on the leaf array via splice, then it directly reflects to the root array

    Array: part 2 (array mainpulation)
     // issue with push()
    const myArr1=[1,2,3,4,5]
    const myArr2=[6,7,8,9,10]
    myArr1.push(myArr2)
    console.log(myArr1) //[ 1, 2, 3, 4, 5, [ 6, 7, 8, 9, 10 ] ] we cam observe that whole myArr2 is taken as as element of myArr1 :: this whole [ 6, 7, 8, 9, 10 ] is taken as 6th lement as myArr1 
    // so inorder to acces the elemnt 7: 
    console.log(myArr1[5][1])


    // issue with concat() // the diffrence makes here from push() is  in concat we need to store to another variable for displaying unlike in push() we can directly access without taking new variable
    const myArr1=[1,2,3,4,5]
    const myArr2=[6,7,8,9,10]
    const result=myArr1.concat(myArr2)
    console.log(result[7]) 
    // Note: concat() is the best appraoch among 2 since, it concantate exactly at the end of new array at the last of previous one

    // Alternate to concat() is using spread operator, since in mordern code we see this alot:)  
    const myArr1=[1,2,3,4,5]
    const myArr2=[6,7,8,9,10]
    const result=[...myArr1,...myArr2] // we can even add more array to it
    console.log(result); //[1,2,3,4,5,6,7,8,9,10]

    // complex nested array
    const ar1 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
    console.log(ar1[2][2][2][1]); // outputs 10

    // using via flat all the nested array becomes an consecutive individual element
    const result=ar1.flat(Infinity)
    console.log(result); [1,2,3,4,5,6,7,8,9,10]

    // isArray => if variable is array then, returns as True else False
    const vicky=[1,2]
    const acharjee=1;
    console.log(Array.isArray(acharjee)); //false
    console.log(Array.isArray(vicky)); //false

    //from method
    const res=Array.from("vicky")
    console.log(res); // converts string into array element as : [ 'v', 'i', 'c', 'k', 'y' ]

    // from as object
    const obj={name:"vicky",age:25}
    const res2=Array.from(obj)
    console.log(res2); // outputs as error

    // of method
    let score1=100
    let score2=200
    let score3=300
    console.log(Array.of(score1,score2,score3)); //[ 100, 200, 300 ] //of operator adds all the variable in a single array one by one

    //There's a way to access string as array index
    console.log('2 want pizza'[0]); // returns 2
    console.log('I want pizza'[4]); // returns n

--------------------------------------------------------------------------------------------------------------------------------
--Objects: 
    // An object is an important topic in jsavaScript
    // An object is a collection of key-value pairs
    // An object is a collection of properties
    // An object is a collection of methods
    // An object is a collection of Functions
    // An object is a collection of variables
    // An object is a collection of data
    // An object is a collection of information
    
        //SingleTon
        //Object Literals

        // way to create Objects
        //1. Object Literal
        let obj1={
            name:"vicky",
            class:"btch"
            }
            // ** NOTE: all the key in objects are acceprted as string, if in genral we declare it normal variable then also internally it converts and accept as String
            // There are two ways to access objects
            //1. Dot Notation
            // console.log(obj1.name);// vicky
            //2. Bracket Notation
            // console.log(obj1['name']);// vicky
            //  ** NOTE: . notation is kinda new approach where as, using square brackets used as main scenario approach
            //  ** NOTE: we can use bracket notation with variables also
            //  ** NOTE: if we need  valid reason of maiking squate braces much added advantages from . notation is:

            // creation of symbol variable
            let symbol=Symbol("keyOne")
            // creating new object for symbol example
            const mySym={
               "vic Name":"vicky",
                age:21,
                [symbol]:"thisIsKey"
            }
            // log using . notation
            console.log(mySym.symbol)// thisIsKey
            // So using dot notation we got the result but partially since ithis is not the correct approach 

            // log using bracket notation
            console.log(mySym[symbol])// thisIsKey ** correct approach

            //another very very imporatnt this is, if bychnace the key in object is within string manually " " then there is no chace for accessing using dont notation, there we need to use [] braces
            // Example taking the same object from above
            
            // with dot notation
            console.log(mySym.vic name);// throws an error since there should be no space in variable naming
            // with bracket notation
            console.log(mySym["vic name"]);// vicky.... since using [] we can access by embedding it into a string
    
    // Freezing an object
            // ** NOTE: we can freeze an object using Object.freeze() method
            // any cahneges made after the declaration of freeze method, will not make anychanges further on
            const obj2={
            name:"vicky", // type string
            age:21, //type string
            isLoggedIn:true, //type boolean
            counLogSession:["monday","wednesday"], //type array
            }
            obj2.name="vicky-acharjee"
            console.log(obj2.name); // vicky-acharjee
            // now we will freeze
            Object.freeze(obj2)
            obj2.name="vicky-acharjee-2"// no changes had been made here since the obj2 has already been freezed
            console.log(obj2.name); // vicky-acharjee                         

    // Methods or Function in objects:
        let myObj={
            name:"vicky"
            greet:function(){
                console.log("Hey there everyone")
            }
        }
        myObj.greet()// Hey there everyone
    
    // we can also define methods using arrow functions
        let myObj2={
            name:"vicky",
            greet:()=>{
                console.log("Hey there everyone from arrow functions")
            }
        }
        myObj2.greet()// Hey there everyone from arrow functons

    // using this method,
    // using this method we ill be accessible to get any refrence from the object
    // Example
        let thisObj={
            name:"vicky",
            greet:function(){
                console.log("hi "+this.vicky) // here we used as this to get the refrence from the object
            }
        }
       ** What is the purpose of the “this” keyword in JavaScript?
       ** The this keyword refers to the object that is executing the current function or method.
          It allows access to object properties and methods within the context of that object
    // NOTE: *** Very Very important, using arrow functions we are accessed to use .this keyword... it will throw an error 

                all functons line up:
                const funobj={
                name:"vicky",
                greet:function(){
                    console.log("hey there everyone");
                },
                greet2:()=>{
                    console.log("hey from arrow functions");
                },
                greet3(){
                    console.log("hey from "+this.name)
             }
            }
             console.log(funobj.greet()); // noob approach
             funobj.greet2();
             funobj.greet3();
        //Note:
        if we will console.log() only the function name, not using() then,
        it will return the function itself, not the output of the function
        Example:
        console.log(funobj.greet); // it will return function 
        // this: [Function: greet]

let state="Meghalaya" // creating a variable for object refrence passing
const obj_one={}
obj_one.name="vicky",
obj_one.age=21,
obj_one["city"]="shillong"
obj_one.sstate=state

console.log(obj_one);

    //nested objects:
    const person={
        userInfo:{
            userFullName:{
                firstName:"vicky",
                lastName:"Acharjee"
            },
            userAge:21,
            UserCity:"shillong",
            userQualification:{
                degree:"Btech",
                branch:"CSE",
                college:"NIT",
                state:"trichy",
            }
        },
        isLoggedIn:true,
        contriesVisited:["india","usa","japan","norway"],
        cards:[
            {cardNumber:"1234567890123456",cardType:"visa"},
            {cardNumber:"9876543210987654",cardType:"mastercard"},
        ]
    }
    console.log(person.userInfo.userFullName.firstName); // printing first name of user
    console.log(person.userInfo.userAge); // printing age of user, 21
    console.log(person.contriesVisited[3]);
    console.log(person.cards[0].cardType);
    console.log(person.cards[1].cardType);

    // Merging two or more object at one objects
    const object1={
        name:"vicky",
        city:"blr"
    }
    const object2={
        name2:"Nivii",
        city2:"Qatar"
    }
    // 1 WAY:
    // using confuse approach ** note:: never use just for the clarification purpose
    // const res={object1,object2}
    // console.log(res);
    // it returns like this:: {
    //   object1: { name: 'vicky', city: 'blr' },
    //   object2: { name: 'Nivii', city: 'Qatar' }
    // }

    // 2 WAY: 
    //using assign method from object library
    const resultOne=Object.assign(object1,object2)
    console.log(resultOne);

    // 3 WAY:
    //using spread operator
    const resultTwo={...object1, ...object2}
    // console.log(resultTwo); //{ name: 'vicky', city: 'blr', name2: 'Nivii', city2: 'Qatar' }

    // NOTE: very very important, whenever merging two objects always have the property unique between two or more objects, else the chanes of collision may happen

// Objects keys, value, entries    
console.log(Object.keys(object1));
console.log(Object.values(object1));
console.log(Object.entries(object1));
// Object.entries makes Array of Array 
// [
//   [ 'name', 'vicky' ],
//   [ 'city', 'blr' ],
//   [ 'name2', 'Nivii' ],
//   [ 'city2', 'Qatar' ]
// ]

//hasOwnProperty
console.log(object1.hasOwnProperty('name')); //true // checks the properties exist or not in the object returns in boolean

//object de-structure

// Object de-structure
const object={
    name:"vicky",
    age:21,
    cityOfOrigin:"shillong"
}
// console.log(object.cityOfOrigin); //shillong
const {cityOfOrigin}=object
const {cityOfOrigin:city}=object
console.log(cityOfOrigin); //shillong
console.log(city); //shillong

--------------------------------------------------------------------------------------------------------------------------------
--Difference between between function and method:

In JavaScript, the terms "function" and "method" are often used interchangeably, but there is a subtle difference between them.

Function: A function is a block of code that can be called multiple times from different parts of your program. 
          It is a self-contained piece of code that takes in arguments, executes a set of statements, and returns a value. 
          Functions are not part of an object and are defined independently.
            //Example
            function add(x, y) {
            return x + y;
            }

Method: A method is a function that is part of an object.
        It is a function that is defined inside an object and is used to perform an action on that object.
        Methods are called on an instance of an object, and they have access to the object's properties and other methods.
            //Example
            const person = {
            name: 'John',
            sayHello: function() {
                console.log(`Hello, my name is ${this.name}!`);
            }
            };
            person.sayHello(); // Output: Hello, my name is John!
    
    To summarize:
    A function is a standalone block of code that can be called independently.
    A method is a function that is part of an object and is used to perform an action on that object.        

--------------------------------------------------------------------------------------------------------------------------------
--Functions:
Functions are reusable blocks of code that can be called multiple times from different parts of your program.
They are defined using the function keyword followed by the name of the function and a set of parentheses that
contain the function's parameters.

    Example: 
        function myFunction(){
        // statement inside the block of the function
        }

        NOTE: myFunction is the refrence of this function.
              where as, myFunction() with parentheses is calling an function.

    // Adding two number in general:
    function myFunc(x,y){
        console.log( x+y);   
    }
    myFunc() // nan, this happendns bcoz functio is expecting number, but passed nothing then it log the output as not a number
    myFunc(5,6) // 11

    // using return keyword:
    function myFuncTwo(a,b) {
        return a+b;
    }
    let res=myFuncTwo(1,2);
    console.log(res);

    function myFuncThree(a,b) {
        console.log(a,b);
        }
        myFuncThree(1,2) // 1 2
        myFuncThree(1,2,3) // 1 2
        myFuncThree() // undefined undefined
        myFuncThree(1) // 1 undefined
        myFuncThree(1,2,3,4) // 1 2
        myFuncThree(1,2,3,4,5) // 1 2
       
    // parameter and argument:
    parameter:
    - parameter is the variable that is declared in the function definition.
    - parameter is the variable that is used to pass the value to the function.
    - parameter is the variable that is used to receive the value from the function.
    - parameter is the variable that is used to return the value from the function.

        example:
        function myFunc(x,y){ // x,y are the varaible passesd as parameter
            console.log(x,y);
            }
    argument:
    - argument is the value that is passed to the function.
    - argument is the value that is passed to the function through the parameter.
    - argument is the value that is passed to the function through the function call.
    - argument is the value that is passed to the function through the function definition.

        example:
        function myFunc(x,y){
            console.log(x,y);
        }
        myFunc(1,2) // 1 2 // given as argument to the function to execute.

// Facts about return statement:
- return statement is used to return the value from the function.
- return statement is used to exit the function.
- return statement is used to pass the value to the caller function.
- return statement is used to pass the value to the function that called the current function.
- return statement is used to pass the value to the function that is calling the current function.
- return statement is used to pass the value to the function that is being called by the current function

    function myReturn(a,b) {
        console.log(a+b);
    }
    myReturn(5,6);

    // Here we can see the main purpose of return statement
    function myReturnTwo(a,b) {
        console.log(a+b); //  X WRONG METHOD
    }
    const result=myReturn(5,6);
    console.log(result); //undefined

    function myReturnThree(a,b) {
        return a+b; //  RIGHT METHOD
    }
    const result2=myReturnThree(5,6);
    console.log(result); // 11

    // NOTE: anything written after return statement passed in function will not be accepted

// calling a function with a validation:
    function callMe(name) {
        if (name===undefined) { // (!name) another form
            console.log("plz pass the name as argument");
            return // this return keyword is very impt since if the name is undefined then it will pass as  'plz pass the name as argument' plus the below line too... so its impt to stop our function execution.
        }
        return `Hello ${name}`
    }
    console.log(callMe('vicky'));//Hello vicky
    console.log(callMe());//Hello plz pass the name as argument
                                OR
    // using default parameter                            
    function callMe(name="user") {
    return `Hello ${name}`
    }
    console.log(callMe()); //hello user    // no need for validation just pass the Default value in the parameter itself.                        
--------------------------------------------------------------------------------------------------------------------------------

-- rest operator
// rest operator is used to pass multiple arguments to a function.
// rest operator is used to pass multiple values to a function.
// rest operator is used to pass multiple parameters to a function.
// rest operator is used to pass multiple arguments to a function.  

    // example: in this example we will see the advantage of having the rest operator, since its dynamically accepting the multiple values mabe one or many
    // NOTE: values passed in the argument are accepted as array formation eg: [1,2,3,4,5]
    function myShoppingCart(...value) {
        // console.log( value);
        let sum=0
        for(let i=0;i<value.length;i++){
        sum=sum+value[i];
        console.log(sum);
        }
    }
    myShoppingCart(1,2,3,4,5);//15

    **Pasing object in the function:
    // passing an object in the function means how using the classic functions we can retrieve the data from the object
    // There are two ways to perform

    // 1. standard way:
        const obj={
        productName:"Ipone",
        price:10000,
        }
    function objFunc(info) {
    return `The product name is ${info.productName} and its price is ${info.price}`
    }
    console.log(objFunc(obj)); //The product name is Ipone and its price is 10000

    // 2. another way is: directly embed the object in the parameter itself
    console.log(objFunc(
    {
     productName:"samsung",
     price:20000,
    }
    )); //The product name is samsung and its price is 20000

      **Pasing array in the function:
    // 1. passing as array [standard form]
    const myArray=[12,3,33,3];
    function arrayFunc(arr){
        console.log("The  array is ", arr[1]);
    }
    console.log(arrayFunc(myArray)); //The  array is  3

    // 2. Another method is directly passing the set of array as an parameter
    console.log(arrayFunc([1,2,3])); //The  array is  2 
--------------------------------------------------------------------------------------------------------------------------------    
--Scope:
// scope is the region of the code where a variable is defined and can be accessed
// there are two types of scope in JavaScript
// 1. Global scope
// 2. Local scope

//Technical naming jargans
// 1. Block scope
// 2. Function scope
// 3. Lexical scope
// 4. Closure scope
// 5. Module scope
// 6. Arrow function scope

var: var is independent of the scopes, which means it can be accessed anywhere in or within the scopes
let and const: let and const are dependent on the scopes, which means they can only be accessed.

    Example:
    let a=10;
    const b=20;
    var c=30;

    if (true) {
        let a=100;
        const b=200;
        var c=300;
    }
    console.log(a);//10
    console.log(b);//20
    console.log(c);//300 // since the var is independent of scoping, so it is intepreting line by line and over-riding, and the value got updated inside if block to 300. 
--------------------------------------------------------------------------------------------------------------------------------    
--Scope-Manipulation and Mini-Hoisting:
    Scenario 1:
        function one() {
            let userName="vicky";
            function two() {
                let website="youtube"
                console.log(userName);
            }
            // console.log(website);  // reaching this line will pas an error as website not defined
            two()
        }
        one()

    Scenario 2:
        function userName(name) {
            if (name==="vicky") {
                console.log("hey vicky");
                let outterName="aka";
            }
            // console.log(outterName); //reaching this line will pas an error as website not defined
        }
        userName("vicky")

// mini-hoisting:

     // classic JS function.
    function addOne(value) {
    return value+1;
    }
 console.log(addOne(1)); //2

// Expression JS function.
    let addTwo=function (value) {
        return value+1;
    }
 console.log(addTwo(2)); //3
            
  // NOTE: now we will call both the function and initiliaze after it.

    console.log(addOne(1));
    function addOne(value) {
        return value+1;
    } // This is working normal, not any changes

    console.log(addTwo(2));
    let addTwo=function (value) {
        return value+1;
    }// this throws an error as 'Cannot access 'addTwo' before initialization', bcoz in callstack the function is given another priority queue, and here its holded as an expression (variable).
--------------------------------------------------------------------------------------------------------------------------------    

--this-keyword and Arrow Functions:
    const data={
    ProductName:"gta",
    price:999,
    welcomeMessage:function () {
        console.log("Hello ",this.ProductName);
        console.log(this); // NOTE: if we log this then the current context of the object is displayed.
    }
    }
    console.log(data.welcomeMessage()); // hello gta
    data.ProductName="igi" // override productName from gta to igi.
    console.log(data.welcomeMessage()); // hello igi
    
    //checking its global object
    console.log(this);// NOTE: this returns nothing since we are under node environment
                     // NOTE: same this inside browser environemt we would do then  it returned the global window object.

    function callMe() {
    console.log(this);
    }                  
    callMe() // this retruns the current context of this particular function.

//Arrow Functions:
//Arrow functions:
// 1. Arrow functions do not have their own this context.
// 2. Arrow functions do not have their own arguments object.
// 3. Arrow functions do not have their own super keyword.    

syntax:
const addOne=(value)=>value+1;

const addOne=(value)=>value+1; 
const addOne=(value)=>{return value+1;}
const addOne=(value)=>{value+1;} // this will throw an error as we are not returning anything.

    // Again theres a constraints, since arrow functions dosent store there own context execution.
    // Example: 
                // arrowOne() // again this throws as an error, since this is stored as a expression (variable) and it dosent have its own context 
                const arrowOne=()=>{
                console.log("hello from arrow functions");
                }

// implicit arrow functions:
// NOTE: VERY important, whenever we use arrow function implicitly then, its not madatory to use return functions.
const implicitArrow=()=> console.log(123);
const implicitArrow2=(n1,n2)=> n1+n2; //passing as parameter too 
const implicitArrow3=(n1,n2)=>(n1-n2); // if makes confuse then we are permitted to use () braces

// Explicit arrow functions:
// NOTE: VERY important, whenever we use arrow function explicitly then, its madatory to use return
// whenever {} braces comes then it is mandatory to use the return keyword.
const explicitArrow=()=>{
  return 123
};

// CONFUSION ARISE, we generally use explicit arrow functions, since implicit arrow functions, cant hadle objects, lets demonstarte it with an scenario:
const obj1={  
}
// now using, implicit arrow function
// const implicitArrowFunction=(n1,n2)=>{name:"vickyA"} // incorrect way
const implicitArrowFunction=(n1,n2)=>({name:"vickyA"}) 
console.log(implicitArrowFunction(1,2)); // correct way                
--------------------------------------------------------------------------------------------------------------------------------    
--IIFE (immediately invoked function expression):
// IIFE is a function that is invoked immediately after its definition.
// IIFE is used to create a new scope and to prevent global variables.
// it basically avoids from global scoping.

    //noraml function:
    function callMe(){
        console.log("hello")
    }
    callMe() //hello

    //using IIFE:
    // just use (this for function) (this for call) <-Technique to remember.
    (function callme(){
        console.log("hello from iife)
    })() // hello from iife

    // Note if we want to use more than one IIFE in a single scope then always use to conclude with ;
        Example:
        ->The single scope{
        (function fromIifeOne(){
        console.log("hello from iife)
        })(); // The scenario where we are using (;) SEMICOLON

        (function fromIifeTwo(){
        console.log("hello from iife)
        })();
        }

    // we can even pass the, parameter to it
    (function calleMe(name))(
        console.log("hello from iife, "+name)
    )("vicky") // hello from iife vicky     

    // There are two types of iife, that we can implement
    1.iffe with function name
        ex:
             (function fromIifeOne(){
        console.log("hello from iife)
        })();

    2.iife with aonmous function
        ex:
             (function (){
        console.log("hello from iife)
        })();
        // same thing can be done via arrow function too.
--------------------------------------------------------------------------------------------------------------------------------    
--truthy and falsy:
// truthy values are those values that are treated as true in a conditional statement.
// falsy values are those values that are treated as false in a conditional statement.

// in js there are  falsy values:
    null, false, 0, -0, undefined, null, BigInt, NaN
// in js the truthy values are:
    "0","false"," "<- since there is a space and it indicates the presence of value as space,[],{}

    // prove that an empty array and object are considered as truthy:
        // array
        let arr=[];
        if (arr) {
            console.log("true");
        }
        if (arr.length===0) {
            console.log("true");
        }
        //object
        let obj={}
        if (obj) {
            console.log("true from obj");
        }
        if (Object.keys(obj).length===0) {
            console.log("true from object");
        }

  // Equality check:
    console.log(false==false);// true
    console.log(false=="");// true
    console.log(""==0);// true    
--------------------------------------------------------------------------------------------------------------------------------    

--Nullish Coalescing operator:
// the nullish coalescing operator is a new operator in js that was introduced in es
// it is used to return the first operand if it is not null or undefined, otherwise it returns the second operand.
// it is denoted by the symbol '??'
// it is used to avoid the confusion between the equality operator and the assignment operator.
// Note: only works with  NULL and UNDEFINED.
// generally, we use it while fetching some data from the external sources, likewise third party database etc

    Example:
    let val;
    // with null
    val=null??10;
    console.log(val);//10

    val=10??null;
    console.log(val);//10

    // with undefined
    val=undefined??20;
    console.log(val);//20

    val=20??undefined;
    console.log(val);//20

    // with multiple values:
    val=1??2??3??undefined;
    console.log(val);//1 // Note: always remember, it returns the first number, compulsorily except undefined and Null
--------------------------------------------------------------------------------------------------------------------------------    

--Terniary operator:
// the ternary operator is a shorthand for if-else statement.
// it is used to return one value if the condition is true and another value if the condition is
// false. it is denoted by the symbol '?'

    Syntax:
         condition ? true block : false block

    Example: Demonstrating, whether a person can vote or not.
    const value=18;
    value>=18 ? console.log("yo can vote"):console.log("You are not eligible");
--------------------------------------------------------------------------------------------------------------------------------                 

--Break and Continue in loops:
// break: used to terminate the loop.
    for (let i = 1; i <=3; i++) {
            if (i==2) {
                console.log("Terminated the loop");
                break; 
            }
            console.log( "This is for table number "+ i);     
        } output: only 1 and then Terminated

// continue: used to skip the current iteration and move to the next one.
     for (let i = 1; i <=3; i++) {
            if (i==2) {
                console.log("Terminated the loop");
                continue;
            }
            console.log( "This is for table number "+ i);     
        }// output: 1,3 //Note: only skipped 2nd iteration.
--------------------------------------------------------------------------------------------------------------------------------                 

--Do while:
 // in do while the, first iteration is will be iterated compulsorily, and rest are all based on conditions
    syntax:
    do{
        // statement to be executed.
        // increment or decrement if needed.
    }while(condition)
--------------------------------------------------------------------------------------------------------------------------------                   

-- High order array loops: (forOf and forIn)
    forof: The for...of loop in JavaScript is used to iterate over iterable objects.

  //NOTE: forOf only works with: array, strings, maps,sets, argument-objects,typed array
  //forOf
  
  // with array
    let arr=[1,2,3,4,5];
    for (const num of arr) {
        // console.log(num); //1,2,3,4,5
    }
    // forOf with Strings
    let greetings="hello vicky"
    for (const greet of greetings) {
        // console.log(greet); //hello vicky
    } 
    // OR just a form of practice skipping the space via continue statement.
    let greetingsTwo="hello vicky"
    for (const greet of greetingsTwo) {
        if (greet==" ") {
            continue;
            // console.log("avoided the space");
        }
        // console.log(greet); // hellovicky -> spaces avoided
    }
 // map
    //creating a map object:
    const myMap=new Map();
    myMap.set("name","vicky");
    myMap.set("age","21")
    console.log(myMap); // Map(2) { 'name' => 'vicky', 'age' => '21' }

    // now looping the myMap object:
    // here we will encounter an issue i.e, whole key and value is been printed.
    for (const key of myMap) {
        console.log(key); //[ 'name', 'vicky' ]  [ 'age', '21' ]
    }
    //to print only the keys then:
    for (const [key,value] of myMap) { // now the map object has been de-structured
        console.log(key); //name and age
    }
    //to print only the values of the key then:
    for (const [key,value] of myMap) { // now the map object has been de-structured
        console.log(value); //vicky and 21
    }  

                               END-FOROF

// forIn loop: for...in is used to loop over the properties of an object.
               It iterates over enumerable properties, which include both own 
               properties and inherited properties unless explicitly filtered.

 //NOTE: forIn only works with: objects, arrays, Strings, Avoid with non-enumerable or Symbol properties

 // Objects:
    const myObj={
        YourName:"legend",
        YourAge:22,
    }
    // for key
    for (const key in myObj) {
        console.log(key); // this simply returns the key i.e YourName and YourAge
        }
    // for value    
    // NOTE: here, if we want to print the value of myObj then:        
    for (const key in myObj) {
        console.log(myObj[key]); //legend and 22
    }    

 // array:
 let arrTwo=['js','java']
 // for key in forIn:
 for (const key in arrTwo) {
    console.log(key); // Note: in forOf loop simply u will get the key of array, but here it retuens in the index number not the value.
 }

 // for value in forIn:
 for (const key in arrTwo) {
    console.log(arrTwo[key]); // Note: we got the value of it. 
 }

 //map: NOTE: NO USE X
 //creating a map object:
    const myMapTwo=new Map();

    myMapTwo.set(
        "class","12",
        "sec","A"
    )
    console.log(myMapTwo); // { 'class' => '12' }

 // using forIn:
    for (const key in myMapTwo) {
       console.log(key); // returns blank.. sinc maps are not iretable
    }  
                             END-FORIN
--------------------------------------------------------------------------------------------------------------------------------                   
--forEach:
//forEach() is a method that calls a provided function once for each element in an array. 
// forEach doesnt returns the value

    syntax: 
        forEach(callBackFunction
         {statement block}
         )

    Example 1:
        const thisArray=[1,2,3,4]
        thisArray.forEach((i)=>{
            console.log(i); // 1,2,3,4
         }
         )     
    Note: in forEach loop is has the 3 parameter i.e value, Index, Full Array.
    Example:
    thisArray.forEach((i,index,arr)=>{
    console.log(`The value for ${index} is ${i} and the array is ${arr}`);
    })
    outPut:
    The value for 0 is 1 and the array is 1,2,3,4
    The value for 1 is 2 and the array is 1,2,3,4
    The value for 2 is 3 and the array is 1,2,3,4

    Example 2:
    // doing the operation with forEach as array of object
    // Very common operation:

    const programming=[
    {
        langName:"java",
        fileName:"java"
    },
    {
        langName:"javaScript",
        fileName:"js"
    },
    {
        langName:"C++",
        fileName:"cpp"
    },
    {
        langName:"php",
        fileName:"php"
    }
    ]

    programming.forEach((item)=>{
        console.log(`The file name is ${item.langName} and its extension is ${item.fileName}`);
    })
    Output:
    The file name is java and its extension is java
    The file name is javaScript and its extension is js
    The file name is C++ and its extension is cpp
    The file name is php and its extension is php

    ISSUE with forEach:
    1. It does not return anything
    2. It does not support break and continue statement

    scenario: suppose i want to return something via this Function.
    const value=array.foreach((item)={
       return item;
    })
    console.log(value)// returns undefined, this is the issue.
--------------------------------------------------------------------------------------------------------------------------------                   

// Filter: The filter() method in JavaScript is a powerful
           tool for working with arrays. It creates a new array with all 
           elements that pass the test implemented by a provided function.
           
           // It does not change the original array.

           // filter works in a philosophy, like if the condition is true then it immediately returns the current context of execution.

    //Filter: (Filter functons returns the value)
    // Note: filter returns, so make a new variable and add to it.
    myArray=[1,2,3,4,5]
    // const filter1=myArray.filter((num)=>num>3) // Implicit
    const filter1=myArray.filter((num)=>{
    return num>3; //explicit, if used {} braces then, use return,since we returning a value
    })
    console.log(filter1); //4,5

     Example scenario showing forEach doing the same:
        const newArr=[] // new array for the result output
        const newFilter=myArray.forEach((num)=>{
        if (num>3) {
            newArr.push(num)
        }
        })
        console.log(newArr); [4,5]
        // By observing this, we found that filter is well efficient to use while dealing with these types of scenarios.
        // filter is more efficient than forEach because it returns a new array, while forEach does not return

        //Another Example:

        const books = [
        {
            bookName: "To Kill a Mockingbird",
            bookPrice: 15.99,
            publishYear: 1960
        },
        {
            bookName: "1984",
            bookPrice: 12.99,
            publishYear: 1949
        },
        {
            bookName: "Pride and Prejudice",
            bookPrice: 10.99,
            publishYear: 1813
        },
        {
            bookName: "The Great Gatsby",
            bookPrice: 14.99,
            publishYear: 1925
        },
        {
            bookName: "The Catcher in the Rye",
            bookPrice: 11.99,
            publishYear: 1951
        }
        ];

        // console.log(books);
        let res=books.filter((book)=> book.bookPrice>12)
            res=books.filter((book)=> book.bookPrice>10) // it just override the main book array... and do not affect the main array
            res=books.filter((book)=>book.bookName=="The Catcher in the Rye")
        console.log(res);
--------------------------------------------------------------------------------------------------------------------------------                   
--Reduce:
// Reduce is a method that applies a function against an accumulator and each element in the array.
// It does not change the original array.
// The accumulator is a value that is kept as a result of applying the function to the elements of
   the array. The function is called for each element in the array and the result is stored in
 
    syntax for .reduce is:
    array.reduce((callBackFunction,initial))
    ->callBackFunction contains the accumulator and the item:(acc,item)
    ->initial is the initial value of the accumulator

    Example:
    //Reduce
    const shoppingCart=[
    {
        item:"apple",
        price:299,
        quantity:1
    },
    {
        item:"Banana",
        price:99,
        quantity:2
    },
    {
        item:"grapes",
        price:199,
        quantity:1
    }
    ]
    //Explicit return
    const price=shoppingCart.reduce((acc,item)=>{
    return acc+item.price;
    },0)// 597   // always remember, using of {} braces mean return key will be used

    //Implicit return
    const quantity=shoppingCart.reduce((acc,item)=>acc+item.quantity,0)
    console.log(quantity); //4
--------------------------------------------------------------------------------------------------------------------------------                   

--Map:
// Map is a method that creates a new array with the results of applying a provided function on every element in this array.
// It does not change the original array.
    syntax:
    array.map((callBackFunction))
    ->callBackFunction contains the item:(item)
    ->return value will be used to create a new array
   
    Example:
    //Map
    let arr=[1,2,3,4]
    let result=arr.map((n)=>{
    return n*10;
    })
    console.log(result); // [10,20,30,40]

    result=arr.map((n)=>{
    return n+10;
    })
    console.log(result); // [ 11, 12, 13, 14 ]
--------------------------------------------------------------------------------------------------------------------------------                   

-- Chaining in MAP and FILTER:
   Example 1:
    let array=[1,2,3,4,5,6,7,8,9]
    const chain1=array.map((n)=>n*10)
                    .map((n)=>n+1)  
    console.log(chain1); // [11, 21, 31, 41, 51,61, 71, 81, 91]

    Example 2:
    const chain2=arr.map((n)=>n*20)
                    .map((n)=>n+12)
                    .filter((n)=>n>=52)
    console.log(chain2); // [ 52, 72, 92 ]


    //practical example: print only even numbers
    // using map.
        let array=[1,2,3,4,5,6,7,8,9]
        const answer=array.map((n)=>{
        if (n%2==0) {
            return `${n} is Even`
        }
        else{
            return `${n} is odd`
        }
        })
        console.log(answer);

        Example 2:
        let array2=[1,2,3,4,5,6,7,8,9]
        const answer=array2.filter((n)=>{
        return n%2==0
        })
        console.log(answer); //[ 2, 4, 6, 8 ]
--------------------------------------------------------------------------------------------------------------------------------                   

-- DOM Document object model:
// DOM is a programming interface for HTML and XML documents. It defines the logical structure of documents
   and the way a document is accessed and manipulated.

// NOTE: in browser, the global object is the   WINDOW object.
// window is the global object in browser.
// that means this is the root for all the other object.
// in node.js the global object is the process object.

        Example:
        <!DOCTYPE html>
        <html>
        <head>
            <title>Document</title>
        </head>
        <body>
            <h1>Hello</h1>
        </body>
        </html>
        
        DOM working:
        // window-> document-> body-> h1-> textnode(Hello)


//Facts about window object:
1. Global Object: The window object is the global object in a web browser, meaning that all global variables and functions are properties of the window object.

2. Top-Level Object: The window object is the top-level object in the browser's object hierarchy, and all other objects, including the document object, are children of the window object.

3. Window Object is not an Object: Despite its name, the window object is not an instance of the Object class. Instead, it is a unique object that is created by the browser.

4. Window Object is not a Constructor: The window object is not a constructor function, and it cannot be used to create new objects using the new keyword.

5. Window Object has no Prototype: The window object does not have a prototype chain, which means that it does not inherit properties from any other object.

6. Window Object is not Enumerable: The properties of the window object are not enumerable, which means that they cannot be iterated over using a for...in loop.

7. Window Object has a lot of Properties: The window object has a large number of properties, including properties that provide access to the document object, the browser's history, and the browser's screen.

8. Window Object has a lot of Methods: The window object has a large number of methods, including methods that provide access to the browser's alert and confirm boxes, the browser's prompt box, and the browser's print function.

9. Window Object is not the same as the Global Object: While the window object is the global object in a web browser, it is not the same as the global object in other environments, such as Node.js.

10. Window Object is not supported in all Browsers: While the window object is supported in most modern web browsers, it is not supported in all browsers, such as some older versions of Internet Explorer.

    //Some commonly used properties used in window objects are:
    window.location: provides access to the URL of the current document
    window.document: provides access to the document object
    window.history: provides access to the browser's history
    window.screen: provides access to the browser's screen
    window.alert(): displays a message box with a single button
    window.confirm(): displays a message box with two buttons (OK and Cancel)
    window.prompt(): displays a message box with a text input field
    window.print(): prints the current document
    window.setTimeout(): executes a function after a specified delay
    window.setInterval(): executes a function at regular intervals

    Note: we generally dont need to always embed "window" suppose we want to access document, then we can directly console log window.
--------------------------------------------------------------------------------------------------------------------------------                   

--DOM multipliacion:
 document.getElementById(): returns the element with the specified id.

┌─────────────────────----------------------------------------------------------──────┐
│                           
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Document</title>
        </head>
        <body>
            <h1  id="heading" class="bg-body">Hello world</h1>
        </body>
        </html>                      
│                           
└─────────────────────────────────────────────────────────────────────────────────────┘

    //returns the tag
    document.getElementById('heading')
    returns: <h1 id=​"heading" class=​"bg-body">​Hello world​</h1>​ // returns the complete tag with a id 'heading'

    // techniue to retrieve id
    document.getElementById('heading').id
    returns: 'heading'
    OR
    //via getAttribute() // this method basically returns the value, provided the key
    document.getElementById('heading').getAttribute('id')
    returns: 'heading'
    
    
    // techniue to retrieve className
    document.getElementById('heading').className // here we have to provide the className not the class
    returns: 'bg-body'
    OR
    //via getAttribute() // this method basically returns the value, provided the key 
    document.getElementById('heading').getAttribute('class')
    returns: 'bg-body'

    // set-ing an attribute via setAttribute():
    document.getElementById('heading').setAttribute('heading','vicky')
    retruns: <h1  id="heading" class="vicky">Hello world</h1>

    -> Manipulating the css via .style attribute
       document.getElementById('heading').style.color="red" // the text color changes to red.
                    or // we can even put it into a variable:
       var heading = document.getElementById('heading');
       heading.style.color = "red";
       heading.style.backgroundColor = "red"; etc etc

    -> Text Manipulation: while displaying
       1. innerHTML
       2. textContent
       3. innerText

       //index.html
        <h1  id="heading" class="bg-body">Hello world <span>hello from span</span> </h1>
        //JS
        const title=document.getElementById('heading')

        // this is the difference btw all these 3
        //innerHTML
        title.innerHTML
        'Hello world<span style="display:none;">hello from span</span>\n    ' // returns the whole html tag
        //textContent 
        title.textContent
        'Hello worldhello from span\n    returns the content for all the tags
        //innerText '
        title.innerText
        'Hello world'  // returns only the exact text of title
--------------------------------------------------------------------------------------------------------------------------------

--Dom selectors:
1. document.getElementById('id') // select the tag by id
example: document.getElementById('heading')


2. document.querySelector('css selector') // this gets **first** selected by query only. 
//example: Note: querySelector only selects first tag, irrespective of many
        document.querySelector('h1') // returns the first h1 tag
        document.querySelector('#heading') // returns the first element with id heading
        document.querySelector('.bg-body') // returns the first element with class bg-body
        document.querySelector('h1.bg-body') // returns the first h1 tag with class bg-body
        document.querySelector('h1.bg-body#heading') // returns the first h1 tag with class

3. document.querySelectorAll('css selector') // there not much diff btw these two, but the only difference is it selects all the tags of same type.
//example:Note: querySelectorAll selects all the tags, irrespective of how many.
        document.querySelectorAll('h1') // returns all the h1 tags
        document.querySelectorAll('#heading') // returns all the elements with id heading
        document.querySelectorAll('.bg-body') // returns all the elements with class bg-body
        document.querySelectorAll('h1.bg-body') // returns all the h1 tags with class bg-body
   
4. document.getElementsByClassName('class')// this selects the tag by className
//example:Note: getElementsByClassName returns all the tags of same class
        document.getElementsByClassName('bg-body') // returns all the elements with class bg-body
        document.getElementsByClassName('bg-body')[0] // returns the first element with class bg-body
        document.getElementsByClassName('bg-body')[1] // returns the second element with class bg-body
        document.getElementsByClassName('bg-body')[2] // returns the third element with class bg-body

5. document.getElementsByTagName('tagname') // this selects by the element name
//example:Note: getElementsByTagName returns all the tags of same name
        document.getElementsByTagName('h1') // returns all the h1 tags
        document.getElementsByTagName('h1')[0] // returns the first h1 tag

6. document.getElementsByName('name') // this selects by the Name
//example:Note: getElementsByName returns all the tags of same name
        document.getElementsByName('name') // returns all the elements with name name
        document.getElementsByName('name')[0] // returns the first element with name name
--------------------------------------------------------------------------------------------------------------------------------

--NdeList:
1. NodeList.prototype.forEach() // this is used to loop through the NodeListIn the Document Object Model (DOM),
   a NodeList is a collection of DOM nodes, typically returned by methods like document.querySelectorAll() or childNodes.
   It looks similar to an array, but it’s not exactly the same because it doesn’t have all the array methods (unless converted to an array explicitly).

   Live vs. Static NodeList:

  Live NodeList: Updates automatically when the document is modified (e.g., childNodes).
  Static NodeList: Does not update when the document changes (e.g., document.querySelectorAll()).
  Example:
        const nodeList = document.querySelectorAll('div');
        console.log(nodeList[0]);  // Accesses the first div element

--------------------------------------------------------------------------------------------------------------------------------

--Exercises:
    -- Exercise: given the html as index.html so, select the firs li element and returns the color to green and much padding too

        Solution:
        const title=document.querySelector('li')
        undefined
        title
        <li ">​…​</li>​
        title.style.backgroundColor="green"
        'green'
        title.style.padding="20px"
        '20px'


    -Exercise: given the html as index.html so, select all the li element and returns the color to green and much padding too
        Solution:
        const title=document.querySelectorAll('li')
        undefined
        title.forEach((n)=>{
            n.style.backgroundColor="red"
        })
        'red'
--------------------------------------------------------------------------------------------------------------------------------

--Converting html collect to array.
An HTMLCollection is a collection of elements that are returned by methods like document.getElementById() or document.getElementsByName
const htmlCollection = document.querySelectorAll('div');
const array = Array.from(htmlCollection);
console.log(array); // Output: [div, div, div]
--------------------------------------------------------------------------------------------------------------------------------

-- Element Manipulation:
    
    // accessing the parent class via querySelector.
    const parent=document.querySelector('.parent');

    ->
    console.log(parent); // <div class="parent"> </div>
    console.log(parent.children); // HTMLCollection(5) [div.day, div.day, div.day, div.day, div.day] ... works somehow like array
    console.log(parent.children[0]); // <div class="day">Monday</div>
    console.log(parent.children[1].innerHTML); // Tuesday
    console.log(parent.children[1].classList); // DOMTokenList ["day"]
    console.log(parent.children[1].classList.contains('day')); // true
    console.log(parent.children[1].classList.contains('weekend')); // false

    ->
    // Now looping all the html collection of it:
    for (let i = 0; i < parent.children.length; i++) {
        console.log(parent.children[i].innerText);  
    }
    // output:
            // Monday
            // Tuesday
            // Wednesday
            // Thursday
            // Friday

    
    // -> we can even manipulate via style too:    
        // we can even manipulate via style too:
        parent.children[0].style.color = 'red';
        console.log(parent.children[0].style.color); // red
        parent.children[0].style.color = 'green';
        console.log(parent.children[0].style.color); // green
    
    // -> here we will acess the individual child by in-hand Property:
    console.log(parent.firstElementChild.innerHTML); // Monday
    console.log(parent.lastElementChild.innerHTML); // Friday

    // -> accessing its parent element
    const child=document.querySelector('.day')// it just returns the first child until here
    console.log(child.innerHTML); // Monday

    console.log(child.parentElement.className); // parent, here we retrive the root element to this.
    console.log(child.parentElement.children); // HTMLCollection(5) [div.day, div.day, div.day, div.day, div.day]
    console.log(child.parentElement.children[0].innerHTML); // Monday
    console.log(child.nextElementSibling.className); // day
    console.log(child.nextElementSibling.innerHTML); // Tuesday

        // Exercise: creating an HTML file... using js(DOM)
            _____________________________
            <div id="title" class="day">
                <h1>Hello</h1>
            </div>
            _____________________________

            // for div
            const div=document.createElement('div');
            div.className='day';
            div.id="title"

            // for h1
            const h1=document.createElement('h1');
            h1.innerHTML="Hello"
            div.append(h1);
            
            // creating a root, element as document.body
            const root=document.body;
            root.append(div);
















    















                










            












            









